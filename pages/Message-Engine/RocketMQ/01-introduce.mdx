import { LinkCard, LinkCardContainer } from 'components/LinkCard';

# 基本概念

## 为什么选择 RocketMQ

在阿里巴巴初创 RocketMQ 的雏形时期，主要将其应用于异步通信、搜索、社交网络活动流、数据管道和贸易流程中。然而，随着业务量的迅速增长，消息传递集群的压力也日
益增加。最初使用 ActiveMQ，但随着队列和虚拟主题的增加，ActiveMQ 的 IO 模块达到了瓶颈。尝试了市场上流行的消息传递解决方案 Kafka 后，阿里觉得它在低延迟和
高可靠性方面不能完全满足需求。因此，RocketMQ 诞生了。RocketMQ 旨在覆盖从传统的发布/订阅（pub/sub）场景到高容量、实时零误差的交易系统等更广泛的消息用例。

## RocketMQ 的优势

自诞生以来，Apache RocketMQ 凭借其简单的架构、丰富的业务功能和强大的可扩展性，广受企业开发者和云厂商的青睐。经过十余年的大规模应用和优化，RocketMQ 已成
为业内公认的金融级可靠业务消息首选方案，广泛应用于互联网、大数据、移动互联网和物联网等领域的业务场景。

## RocketMQ、ActiveMQ 和 Kafka 的比较

为了更好地理解 RocketMQ 的独特优势，我们来对比一下 RocketMQ、ActiveMQ 和 Kafka 的主要特点。

## RocketMQ 的基本概念

* 主题（Topic）：消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息。
* 消息类型（MessageType）：根据消息传输特性的不同而定义的分类，用于类型管理和安全校验，包括普通消息、顺序消息、事务消息和定时/延时消息。
* 消息队列（MessageQueue）：消息存储和传输的实际容器，也是消息的最小存储单元。
* 消息（Message）：最小的数据传输单元，生产者将业务数据的负载和拓展属性包装成消息发送到服务端。
* 消息视图（MessageView）：面向开发者提供的消息只读接口，可读取消息内部的多个属性和负载信息。
* 消息标签（MessageTag）：细粒度消息分类属性，可在主题层级之下对消息类型进行细分。
* 消息位点（MessageQueueOffset）：每条消息在队列中的唯一坐标，用于消费进度管理。
* 消费位点（ConsumerOffset）：记录每个消费者分组已消费的最新消息位点。
* 消息索引（MessageKey）：面向消息的索引属性，可快速查找对应的消息内容。
* 生产者（Producer）：构建并传输消息到服务端的运行实体。
* 事务检查器（TransactionChecker）：用于执行本地事务检查和异常事务恢复的监听器。
* 事务状态（TransactionResolution）：事务提交的状态标识，包括事务提交、事务回滚和事务未决。
* 消费者分组（ConsumerGroup）：承载多个消费行为一致的消费者的负载均衡分组。
* 消费者（Consumer）：接收并处理消息的运行实体。
* 消费结果（ConsumeResult）：PushConsumer 消费监听器处理消息完成后返回的处理结果。
* 订阅关系（Subscription）：消费者获取消息、处理消息的规则和状态配置。
* 消息过滤：通过订阅指定消息标签对消息进行过滤，确保只接收被过滤后的消息。
* 重置消费位点：在消息持久化存储的时间范围内，重新设置消费者分组的消费进度。
* 消息轨迹：从生产者发出到消费者接收并处理过程中各节点的时间、地点等数据。
* 消息堆积：消费者未能及时消费的消息堆积在服务端。
* 事务消息：支持在分布式场景下保障消息生产和本地事务最终一致性的高级消息类型。
* 定时/延时消息：消息被发送至服务端后，在指定时间后才能被消费。
* 顺序消息：支持消费者按照发送消息的先后顺序获取消息，从而实现顺序处理。

## 参数约束和建议

Apache RocketMQ 系统中存在很多自定义参数和资源命名，在使用 Apache RocketMQ 时建议参考如下说明规范系统设置，避对某些具体参数设置不合理导致应用出现异常。<LinkCardContainer>
    <LinkCard href="https://rocketmq.apache.org/zh/docs/introduction/03limits" />
</LinkCardContainer>